/* Copyright (c) 2001 - 2007 TOPP - www.openplans.org. All rights reserved.
 * This code is licensed under the GPL 2.0 license, available at the root
 * application directory.
 */
package org.geoserver.wps.sextante;

import java.util.HashMap;
import java.util.Iterator;
import java.util.Map;
import java.util.Set;

import org.geotools.process.Process;
import org.opengis.util.ProgressListener;

import es.unex.sextante.core.GeoAlgorithm;
import es.unex.sextante.core.ITaskMonitor;
import es.unex.sextante.core.OutputObjectsSet;
import es.unex.sextante.core.ParametersSet;
import es.unex.sextante.dataObjects.IDataObject;
import es.unex.sextante.exceptions.GeoAlgorithmExecutionException;
import es.unex.sextante.exceptions.WrongParameterIDException;
import es.unex.sextante.geotools.GTOutputFactory;
import es.unex.sextante.outputs.Output;
import es.unex.sextante.parameters.Parameter;
import es.unex.sextante.rasterWrappers.GridExtent;

public class SextanteProcess implements Process{

	/**
	 * A constant to use as a key to identify the output grid extent
	 * as another input parameter of the process. In a SEXTANTE
	 * algorithm this is not a parameter included in the parameters set.
	 */
	public static final Object GRID_EXTENT = "GRID_EXTENT";

	private GeoAlgorithm m_Algorithm;

	/**
	 * Constructs a new process based on a SEXTANTE geoalgorithm
	 * @param algorithm the SEXTANTE geoalgorithm
	 */
	public SextanteProcess(GeoAlgorithm algorithm) {

		m_Algorithm = algorithm;

	}

	public Map<String, Object> execute(Map<String, Object> input,
			ProgressListener monitor) {

		ITaskMonitor taskMonitor = new ProgressListenerTaskMonitor(monitor);

		try {
			setAlgorithmInputs(input);

			/*
			 * Execute the algorithm
			 * The output factory tells the algorithm how to create
			 * new data objects (layers and tables)
			 * Since we are working with GeoTools , we use the
			 * GTOutputFactory, which creates objects based on geotools
			 * data objects (DataStore and GridCoverage)
			 */

			if (m_Algorithm.execute(taskMonitor, new GTOutputFactory())){
				return createReturnMapFromOutputObjects();
			}
			else{
				//if the execution was canceled, we return null
				return null;
			}

		} catch (GeoAlgorithmExecutionException e) {
			e.printStackTrace();
			return null;
		}

	}

	/**
	 * Creates a suitable return map for this process
	 * from the outputs generated by the SEXTANTE algorithm
	 * @return a map with algorithm results
	 */
	private Map<String, Object> createReturnMapFromOutputObjects() {

		Map<String, Object> results = new HashMap<String, Object>();

		OutputObjectsSet outputs = m_Algorithm.getOutputObjects();
		for (int i = 0; i < outputs.getOutputObjectsCount(); i++) {
			Output output = outputs.getOutput(i);
			Object outputObject = output.getOutputObject();
			// if the output object is a layer or a table, we return
			// the inner GeoTools object
			if (outputObject instanceof IDataObject){
				IDataObject dataObject = (IDataObject) outputObject;
				results.put(output.getName(), dataObject.getBaseDataObject());
			}
			else{
				results.put(output.getName(), outputObject);
			}
		}
		return results;

	}

	/**
	 * Sets the input of the SEXTANTE algorithm from the input map
	 * of this process
	 * @param input the input map of this process
	 * @throws WrongParameterIDException
	 */
	private void setAlgorithmInputs(Map<String, Object> input)
						throws WrongParameterIDException {

		ParametersSet paramSet = (ParametersSet) m_Algorithm.getParameters();
		Set<String> keys = input.keySet();
		Iterator<String> iter = keys.iterator();
		while(iter.hasNext()){
			String sKey = iter.next();
			if (!sKey.equals(GRID_EXTENT)){
				Object paramValue = input.get(sKey);
				Parameter param = paramSet.getParameter(sKey);
				param.setParameterValue(paramValue);
			}
			GridExtent ge = (GridExtent) input.get(GRID_EXTENT);
			m_Algorithm.setGridExtent(ge);
		}

	}

}
